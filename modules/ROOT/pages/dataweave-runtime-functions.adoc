= External Functions Available In DataWeave
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: lookup, properties, functions

In addition to the built-in DataWeave functions, Mule Runtime and some modules, connectors, and components for Mule apps provide functions that you can use in
DataWeave scripts. The functions are specific to the module, connector, and
components.

[IMPORTANT]
====
*Deprecation Notice*:

The functions described in this section are deprecated as of Mule Runtime 4.1.4.
Instead of using them, MuleSoft recommends using functions of the same name from
the Mule function module. An important advantage of this change is that you can
call functions in the Mule module from DataWeave functions and variables,
instead of only being able to use them within short expressions in Mule
components.

For details, see xref:dw-mule.adoc[Mule (dw::Mule)].
====

== Mule Runtime Functions

These functions are always available since they are injected by the Mule Runtime.

=== Accessing Properties (p Function)

The `p` function provides access to properties, whether these are:

* Mule property placeholders
* System properties
* Environment properties

For more on configuring properties and how they are handled, see xref:configuring-properties.adoc[Configure Properties].

The following example will log the value of the property `some.property`.

.Example: Property Function Usage
[source,xml,linenums]
----
<flow name="simple">
  <logger message="#[p('some.property')]"/>
</flow>
----

=== Executing a Flow (lookup Function)

The `lookup` function allows for executing a flow within your app and retrieves the
resulting payload, taking the flow's name and an input payload as parameters.

The specified flow is executed using the current attributes, variables, and
error. It only replaces the payload for the first parameter, which must be a Java
type.

= Use `lookup` To Call External Flows
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

From a DataWeave transform, you can trigger the calling of a different flow in your Mule application, and whatever the flow returns is what the expression returns.

You can do this through the following expression:

`lookup("flowName",$)`

Which takes three parameters:

* The name of the flow that must be called
* The payload to send to this flow
* The timeout in milliseconds (optional), for the execution of the target flow. +
If the lookup takes more time than this value, an error is raised.
If no value is specified, this parameter defaults to 2 seconds if the thread that is executing is CPU_LIGHT or CPU_INTENSIVE, or 1 minute when executing from other threads.


.Transform
[source,dataweave,linenums]
----
%dw 2.0
output application/json
---
{
  a: lookup("mySecondFlow",{b:"Hello"})
}
----

.Mule Flow
[source,xml,linenums]
----
<flow name="mySecondFlow">
    <set-payload doc:name="Set Payload" value="#[payload.b + ' world!' ]"/>
</flow>
----

.Output
[source,json,linenums]
----
{
  "a": "Hello world!"
}
----

Please note that only the payload returned by the invoked flow will be assigned.

[WARNING]
====
Always keep in mind that a functional language like DataWeave expects the invocation of the `lookup` function to _not_ have side effects.
As such, the internal workings of the DataWeave engine might cause a `lookup` function to be invoked in parallel with other `lookup`s, or not invoked it at all.

The recommended way to invoke flows is with the Flow Ref (`flow-ref`) component, using the `target` attribute to put the result of the flow in a `var` and then referencing that `var` from within the DataWeave script.
====

Note that `lookup` function does not support calling subflows.


=== Matching Errors by Types (causedBy Function)

The `causedBy` function matches an error by its type, like an error handler
does. This is useful when matching by a super type is required but specific sub-type
logic also needed or when handling a `COMPOSITE_ROUTING` error that contains child
errors of different types.

The error to match against can be implicit, but the type is always a required parameter.

In the following example, a global error handler is set up to handle `SECURITY`
errors in a general way, while specific actions are set up for `HTTP:UNAUTHORIZED`
and `HTTP:FORBIDDEN` errors.

.Example: Error Matcher Function Usage
[source,xml,linenums]
----
<error-handler name="securityHandler">
  <on-error-continue type="SECURITY">
    <!-- general error handling for all SECURITY errors -->
    <choice>
      <when expression="#[error causedBy 'HTTP:UNAUTHORIZED']">
        <!-- specific error handling only for HTTP:UNAUTHORIZED errors -->
      </when>
      <when expression="#[causedBy('HTTP:FORBIDDEN')]">
        <!-- specific error handling only for HTTP:FORBIDDEN errors -->
      </when>
    </choice>
  </on-error-continue>
</error-handler>
----

Notice that the error parameter is used both explicitly and implicitly.

== Connector and Component Functions

When using connectors and components in a Mule app, you can inject functions.
Unlike the Runtime functions, these functions require a namespace, which usually
matches the component name.

For example, in an app using Batch you can use the following expression: `#[Batch::isSuccessfulRecord()]`.

== See Also

xref:dw-functions.adoc[DataWeave Core Functions]

xref:dataweave-types.adoc[DataWeave Types]

xref:dataweave-selectors.adoc[DataWeave Selectors]

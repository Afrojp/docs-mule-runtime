= Split Aggregate Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: anypoint studio, studio, mule, split, aggregate, scope

The Split Aggregate scope splits a collection and processes each part with the components within it in parallel (subject to any limitation in concurrency that has been configured).
After all messages have been processed they will be aggregated before continuing with the flow in the same order they were before splitting the defined collection. 

The Split Aggregate scope can be configured through the following fields described in this table:

[%header,cols="1,3"]
|===
|Child element |Description
|Collection (`collection`) | Specifies the expression that defines the collection of parts to be processed in parallel. By default, it will use the incoming payload.
|==

[%header,cols="1,3"]
|===
|Attribute |Description
|Timeout (`timeout`) | Specifies the timeout for each parallel route. By default there is no timeout.
|Max Concurrency (`maxConcurrency`) | Specifies the maximum level of parallelism that will be used by this router. By default, all routes will run in parallel.
|Target Variable (`target`) | Specifies the variable where to save the processed payload. By default the output will be saved in the flow's payload. 
|Target Value (`targetValue`) | Specifies an expression to evaluate against the operation's output value. The outcome of this expression will be stored in the target variable. By default, this will be the same as the operation's output value.
|===

This XML example adds to every element in the collection the string `"-result"`: 

----
<split-aggregate>
	<collection>
		#[['apple', 'banana', 'orange']]
	</collection>
	<set-payload value="#[payload ++ '-result']"/>
</split-aggregate>

----

Every route starts with the same initial variable values. If a variables is modified within an specific route, this will not affect other routes. If a variable is added or modified in one route then, after aggregation, the value will be the defined by that route. If a variable is added or modified by more than one route then the  value will be a list of all the values defined for that variable within all the routes. 
For example:

----
<set-variable variableName="var1" value="var1"/>
<set-variable variableName="var2" value="var2"/>
<split-aggregate>
	<collection>
		#[['apple', 'banana', 'orange']]
	</collection>
	<choice>
		<when expression="#[payload == 'apple']">
			<set-variable variableName="var2" value="newValue"/>
			<set-variable variableName="var3" value="val1"/>

		</when>
		<when expression="#[payload == 'banana']">
			<set-variable variableName="var3" value="val2"/>
		</when>
		<otherwise>
			<set-variable variableName="var3" value="val3"/>
			<set-variable variableName="var4" value="val4"/>
		</otherwise>
	</choice>
</split-aggregate>
<!-- After aggregation, the variables will be: 
{var1: "var1", var2: "newValue", var3: ["val1, val2, val3"], var4: "val4"} -->
----

== Error Handling

When an error is thrown in one route, since every route is being processed in parallel, Split Aggregate will continue t process each route and then invoke the xref:intro-error-handlers.adoc[Error Handler], with the aggregation of the results and errors of all the routes. For example:

----
<split-aggregate collection="#['banana', 'apple']">
	<choice>
		<when expression="#[payload == 'banana']">
			<!-- Processor that throws exception -->
		</when>
		<otherwise>
			<set-payload value="#[payload ++ '-result']"/>
		</otherwise>
	</choice>
</split-aggregate>
<error-handler>
	<on-error-continue type="COMPOSITE_ROUTING">
		<!-- This will have the error thrown by the above processor --> 
		<logger message="#[error.errorMessage.payload.failures['0']"/>
		<!-- This will be a null value --> 
		<logger message="#[error.errorMessage.payload.failures['1']"/>
		<!-- This will be a null value --> 
		<logger message="#[error.errorMessage.payload.results['0']"/>
		<!-- This will have the result of this (correctly executed) route --> 
		<logger message="#[error.errorMessage.payload.results['1']"/>
	</on-error-continue>
</error-handler>
----

=== Differences between Split Aggregate and For Each scopes

There is an obvious similarity between the Split Aggregate and the xref:for-each-scope-concept.adoc[For Each]: both split the defined collection and process each element in it with the components within the scope. Also, in both cases, each route runs with the same initial context.
The difference with these two scopes are:

1. For Each works sequentially, while the Split Aggregate does it in parallel.
1. The For Each does not modify the payload, while the Split Aggregate will output a collection of the output messages of each iteration.
1. Error handling: since the first mentioned difference, For Each execution will be interrupted when an error is raised (and the Error Handler will be invoked), while Split Aggregate will work as defined before, processing every route before invoking the Error Handler with a `MULE:COMPOSITE_ROUTE` error type.


==== Throws

* `MULE:COMPOSITE_ROUTING`

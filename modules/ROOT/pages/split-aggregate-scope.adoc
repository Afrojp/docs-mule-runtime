= Split Aggregate Scope
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: anypoint studio, studio, mule, split, aggregate, scope

The Split Aggregate scope splits a collection, and processes each part with the components within it in parallel (subject to any limitation in concurrency that had been configured).
After all messages have been processed, they will be aggregated before continuing with the flow, in the same order they were before splitting the defined collection. 

The Split Aggregate scope provides fields described in this table:

[%header,cols="1,3"]
|===
|Attribute |Description
|Collection (`collection`) | Specifies the expression that define the collection of parts to be processed in parallel. By default, it will use the incoming payload.
|Timeout (`timeout`) | Specifies the timeout for each parallel route. The default behaviour is that of no timeout set.
|Max Concurrency (`maxConcurrency`) | Specifies the maximum level of parallelism that will be used by this router. By default, all routes will run in parallel.
|Target Variable (`target`) | Specifies the variable where to save the processed payload. 
|Target Value (`targetValue`) | Specifies an expression to evaluate against the operation's output value. The outcome of this expression will be stored in the target variable. 
|===

This XML example adds to every element in the collection the string `"-result"`: 

----
<split-aggregate>
	<collection>
		['apple', 'banana', 'orange']
	</collection>
	<set-payload value="#[payload ++ '-result']"/>
</split-aggregate>
<!-- payload will now be ['apple-result', 'banana-result', 'orange-result']
----

The example above is equivalent to: 

----
<split-aggregate collection="#[['apple', 'banana', 'orange']]">
	<set-payload value="#[payload ++ '-result']"/>
</split-aggregate>
----

The next example shows that the variables can also be aggregated:
----
<split-aggregate collection="#[['apple', 'banana', 'orange']]">
	<choice>
		<when expression="#[payload == 'apple']">
			<set-variable variableName="var1" value="newValue"/>
			<set-variable variableName="var2" value="val1"/>
		</when>
		<when expression="#[payload == 'banana']">
			<set-variable variableName="var2" value="val2"/>
		</when>
		<otherwise>
			<set-variable variableName="var2" value="val3"/>
		</otherwise>
	</choice>
</split-aggregate>
<!-- After aggregation, the variables will be: {var1: "newValue", var2: ["val1, val2, val3"]} -->
----

=== Differences between Split Aggregate scope and For Each scope

There is an obvious similarity between the Split Aggregate scope and the xref:for-each-scope-concept.adoc[For Each scope]: both split the defined collection and process each part it with the components within the scope. Also, in both cases each route runs with the same initial context.
The difference with these two scopes are:

1. For Each works sequentially, while the Split Aggregate does it in parallel.
1. The For Each output payload is exactly the same as the input payload, while the Split Aggreate will output a collection of the output messages of each iteration.
1. Error handling: since the first mentioned difference, For Each will finish executing after the first encountered error (and invokes the Error Handler), while Split Aggregate will process each route and then invoke the xref:intro-error-handlers.adoc[Error Handler].

==== Throws

* `MULE:COMPOSITE_ROUTING`

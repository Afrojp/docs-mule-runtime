= Mule Application Deployment Model
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: anypoint studio, esb, deploy, architecture

Mule application deployment consists of two main aspects:

* The Mule runtime engine instance
* The Mule applications deployed to that Mule instance

When you deploy applications to CloudHub or to Anypoint Runtime Fabric, these services take care of the Mule runtime engine instances needed to run applications.

When you deploy applications on-premises, you are responsible of the installation and configuration of the Mule runtime engine instances that run your Mule applications.

The following characteristics are specific of Mule runtime engine instances, meaning they only apply for on-premises deployments.

== Running Multiple Applications in one Mule Instance

One instance of Mule runtime engine can run multiple applications, enabling you to include the same namespaces within different applications that neither collide nor share information, which allows additional advantages such as:

* You can break down a complex application into several Mule apps with their specific logic, and then deploy the Mule apps in the same Mule instance
* Clear boundaries for running operations on what a Mule application is
* Mule runtime engine monitors your Mule applications and reloads configuration changes automatically
* Applications can depend on different library versions
* Multiple versions of an application can run within the same Mule instance.

== Application Package and Deployment

Mule runtime engine unpacks all applications at runtime, removes the original `jar` files inside the `/apps` directory, creates a new folder for each application, and names each folder with the same name of the application file without having the `jar` extension.

To confirm a successful deployment check the following:

* The status of the application in the console is: `DEPLOYED`
* An unpacked application folder in the `apps` directory of your Mule instance exists +
For example, for `stockTrader.jar`- `$MULE_HOME/apps/stockTrader`.
* An anchor file exists for a running app
For example, `$MULE_HOME/apps/stockTrader-anchor.txt`

If you want to store your applications in a different location, you can store them on Unix-based systems by creating a symlink to your application directory from `$MULE_HOME/apps`.

== Application and Domain Deployment

Every application is deployed together within a *domain*. By default, your application references the `default` domain, and no further configuration is required. You can see that the domain is deployed with the Mule app in the console:

image::deploy-domain.png[deploy+domain]

If you're deploying multiple applications to the same Mule instance, and the applications must share the same resources, then you can create a common *domain* to define configurations that can be referenced by multiple projects. This practice enables you to expose different services in different projects through the same HTTP host and port without causing any conflicts.

== Deploy Applications in Parallel

You can deploy applications in parallel to on-premises Mule instances. Deploying applications in parallel reduces the startup time when you deploy a large number of apps. To prevent deployment failure, ensure that applications are not dependent on each other because a particular start order cannot be guaranteed.

To enable parallel deployment:

. Package or export your Mule applications to the `/apps` directory of your Mule runtime engine instance.
. Start Mule using the `-M-Dmule.deployment.parallel` option:
+
```
mule -M-Dmule.deployment.parallel
```

After performing these steps, all applications in the `/apps` directory start in parallel.

== Update Applications at Runtime

Updating a Mule application at runtime can be a complex change involving class modifications, endpoint modifications (for example, changing ports, etc), as well as reconfiguring flows. As a result, any application update does a graceful app shutdown under the hood and reconfigures itself. In practice, this is pretty transparent to the user and happens within seconds.

There are several ways you can update an application:

* By dropping the modifications over an existing exploded app folder and touching the master configuration file (`mule-config.xml` located in the app's root directory by default).
* By dropping a new `jar` version of the app into the `$MULE_HOME/apps` directory. Mule detects the `jar` as an existing application and ensures the updated by a clean redeployment of the app. +
Note that Mule discards any modifications to the old application folder. The new app folder is a clean exploded application from a `jar`.

As you see, both integrate pretty well with existing build tools, the preference for one over another really depends on established development practices only.

== Application Hot Deployment

You can modify your Mule application's configuration files and custom classes and reload the app without having to restart Mule.

Mule checks every three seconds for updated configuration files under the `$MULE_HOME/apps` directory, and when it finds one, it reloads the configuration file and the JARs in that application's `java` source directory.
+
If you start Mule and specify an app using the `mule.deploy.applications` property, the hot deployment process works only for the specified app.

To reload an application, you can:

* Touch the anchor file of that application.
* Touch or update any of the Mule configuration files declared in the `mule-artifact.json` file.

For example, if you want to modify one of your custom classes, make your changes to the custom class, copy the updated class to the java directory, then touch the anchor file.

== Troubleshooting

* Mule application fails to start +
If the application fails to start (for example, due a broken configuration file), Mule does not monitor the app for changes (as technically there is no application running). To update the application, redeploy it.
* Communication between Mule instances and the Management pane is disrupted +
Mule instances run independently from the Management pane to execute integration logic and serve API requests. This architecture allows for Mule runtime engine to be deployed strategically and ensures it is not a bottleneck for any communications. +
When an event occurs that causes the Mule instances to get disconnected from the Management pane, they continue to run as designed and execute integration and serve API without interruption. However, new or updated policies are not pulled and updated until the connection is re-established.

== See Also
* xref:shared-resources.adoc[Shared Resources]

= Build an Application from an API Specification
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: build, application, api, specification

During your app development lifecycle, you can build Mule REST or SOAP APIs from an API specification using APIkit.  You develop APIs based on the following modeling languages:

* RAML (RESTful API Modeling Language)
* WSDL (Web Service Description Language)
* OData-Enabled APIs using APIkit OData Extension

By using APIkit in Anypoint Studio, you can simplify the design and implementation of APIs by automating Mule flows creation based on importing either a RAML, or WSDL specification file. After generating the API, you can simulate calls to test the API and then finalize its implementation. +

Additionally, APIkit helps you build applications using Apache Maven, but before you jump into the workflows of building an application using APIkit, learn the basic APIkit anatomy and understand the scaffolding technique that generates Mule flows when you start APIkit projects.

[NOTE]
MuleSoft recommends Design Center for creating and syncing RAML code; however, Anypoint Studio includes a RAML editor that provides syntax validation and suggestions if you want to perform the entire development within Studio.

== APIkit Anatomy
A REST or SOAP project that uses APIkit has the following parts:

* A RAML or WSDL interface.
* A main flow
* Backend flows

.REST Studio Project.
image::mruntime-rest-studio-project.png[REST Studio Project]

.SOAP Studio Project.
image::mruntime-soap-studio-project.png[SOAP Studio Project]

=== API Interface
The interface defines the API, designating resources that contain or access data and specify actions, such as GET and PUT, on the example data

==== REST Interface
The relationship between REST resources and actions is called resource-action pairing. The interface exposes internal data assets requested by the REST service.

==== SOAP Interface
The interface defined by a WSDL file exposes a number of services. Each service has a set of operations. The underlying type of data is XML defined by schemas within the WSDL file or by an imported XSD file.

=== Main Flow
The main flow for these APIs manages these functions:

* Exposes the API using HTTP or Jetty.
* Routes requests between the interface and the backend flows based on the HTTP request.
* Accepts requests, sends responses, and facilitates communication between the interface and API processes.

For REST APIs the api-main flow consists of HTTP Listener and APIkit Router components. The APIkit router is a key message processor that validates requests against the RAML definition, enriches messages, for example by adding default values to the messages, and routes requests to a flow. "Bad request" is returned if the request is invalid, for example, and "Not implemented" is returned if the RAML resource that you request is not associated with a flow.

.REST API Main Flow.
image::mruntime-rest-main-flow.png[REST API Main Flow]

For SOAP APIs the main-api flow consists of HTTP Listener and SOAP Router components.  Based on a WSDL file, the SOAP Router component routes arriving calls to the corresponding flow depending on the resource and method.

.REST API Main Flow.
image::mruntime-soap-main-flow.png[SOAP API Main Flow]

=== Backend Flows
APIkit for REST generates a backend flow for each resource-action pairing in a RAML file. +
APIkit for SOAP generates a backend flow for each operation in a WSDL. +
In the following example, the RAML interface receives the GET request users. The backend flow accesses a database to look up users by id.

.REST API Backend Flows.
image::mruntime-rest-backend-flows.png[REST API Backend Flows]

=== Simulating Calls
For REST APIs, use the API Console to simulate calls to the API. +
For SOAP APIs, use a SOAP testing tool such as SoapUI, to simulate calls to the API.

== Start APIkit Project and Generate Mule Flows
When you create an APIkit project in Studio, you have the option to whether import or not an API definition file and and when you do so, the APIkit scaffolding technique generates different flows for the API. There are three ways to create an APIkit project:

=== Start a New APIkit Project with an API Definition File
Create a project importing a RAML or WSDL file, or reference the file URL:

. Select *File > New > Mule Project*.
. In *Project Name*, enter a name for the project, for example *myproject*. Select or accept the default EE Runtime, for example *Mule Server 4.2.0 EE*.
. In *API Implementation*, check *Specify API Definition File Location or URL*.
. In *Location*, do one of the following:
* Select *Design Center* if you created an `api.raml` file in Design Center. Login to Anypoint Platform if necessary, and select `api.raml`.
* Alternatively, if you didnâ€™t create the RAML in Design Center, select *Browse Files*. Browse to and select the RAML or WSDL file that you created in a text editor.
* For WSDL files, select a service and port from the drop-down menus or accept the defaults.

[start=5]
. Accept the Location default options, and click *Finish*.

.New Mule Project window selecting API specification .
image::mruntime-start-apikit-project-1.png[New Mule Project with API Specification selected]

The APIkit scaffolding technique generates:

* An archetype that contains basic configuration files plus a Mule XML configuration file.
* An implementation of the API that contains:
** For RAML-based APIs:
*** The RAML file appears under the `src/main/resources/api` folder.
*** A main flow with an HTTP Listener.
*** APIkit Router component.
*** Error handlers.
*** RAML dependencies, push or pull changes from one location, such as Studio, to the other, such as Design Center.
*** Backend flows containing REST resource-action mappings.
** For WSDL-based APIs:
*** The WSDL file appears under the `src/main/resources/api` folder.
*** A SOAP Router.
*** A SOAP fault response template.
*** Backend flows containing SOAP message templates.

The below graphics explain the APIkit scaffolding technique:

.RAML Scaffolding.
image::mruntime-raml-scaffolding.png[RAML Scaffolding]

.WSDL Scaffolding.
image::mruntime-wsdl-scaffolding.png[WSDL Scaffolding]

In Studio, the REST API APIkit project looks like this:

.REST API in Anypoint Studio UI with the Package Explorer and Canvas sections.
image::mruntime-rest-api-studio-apikit.png[REST API Anypoint Studio UI with the Package Explorer and Canvas sections]

* The first item shows the project files in the Package Explorer of Studio with the `api.raml` file under src/main/resources/api folder.
* The second item displays the main flow with the APIkit Router.
* The third item displays the APIkit Console.
* The fourth item displays the Error Handling.
* The fifth item display generated flows for each resource method. The generated minimal flows meets the communication operations required by a REST contract.


In Studio, the SOAP API APIkit project looks like this:

.SOAP API in Anypoint Studio UI with the Package Explorer and Canvas sections.
image::mruntime-soap-api-studio-apikit.png[SOAP API Anypoint Studio UI with the Package Explorer and Canvas sections]

* The first item shows the project files in the Package Explorer of Studio with the `example.wsdl` file under src/main/resources/api folder.
* The second item displays the main flow with the SOAP Router.
* The third item displays the SOAP fault response template.
* The fourth item display generated backend flows containing SOAP message templates.

Once you create your APIkit project, you can then continue building the application by simulating calls to test the API and finalize its implementation. See Build Application Workflows for details.


=== Start a New APIkit Project
In Studio, if you create a new APIkit project and do not specify an API definition file, APIkit generates a skeletal RAML file and XML configuration file. Later, you can add an API specification and test the API with the API Console.

. Select *File > New > Mule Project*.
. In *Project Name*, enter a name for the project, for example *myproject*. Select or accept the default EE . Runtime, for example *Mule Server 4.2.0 EE*.
. In *API Implementation*,  do _not_ check *Specify API Definition File Location or URL*. This creates the backend-first APIkit design.
. Accept the other default options, and click *Finish*.

.New Mule Project window.
image::mruntime-start-apikit-project-2.png[New Mule Project window without API specification]


The APIkit scaffolding generates a skeletal RAML file and XML configuration file that includes the following components:

* A main flow <flow name="main-api"></flow>
* HTTP Listener configuration in the main flow
* APIkit Router component
* Error handlers

Later, you can add an API specification to the backend-first APIkit design and generate backend flows to continue building the application. See Build Applications Workflows for details.

=== Start a New APIkit Project by Generating Backend Flows
This procedure assumes you previously:

* Created a RAML file in Studio (RAML editor).
* Created a main flow with an HTTP Listener and APIkit Router components.

When you create a RAML in Studio, generating backend flows is optional. Error handling is generated for a RAML-based API. You need to reference generated flows from the main flow. +
To generate backend flows:

. In the Package Explorer, right-click the project name.
. Select *Mule > Generate Flows From REST API*.

.Generating backend flows from Mule Project.
image::mruntime-start-apikit-project-3.png[Generating backend flows from Mule Project]

The APIkit scaffolding technique generates the backend flows below the main flow, you can then continue building the application by simulating calls to test the API and finalize its implementation. See Build Application Workflows for details.

== Build Applications Workflows
Once you are familiarized with the basic APIkit anatomy and scaffolding technique, review the following workflows that help you build your desired application, from creating the APIkit project, generating Mule flows, simulating calls to the API and finalizing its implementation:

* Build a REST API using APIKit for REST
* Build a SOAP API using APKit for SOAP

Additionally, you can:

* Convert an Existing Mule Project to an APIkit Project: add an API specification to an existing APIkit backend-first design, define API definition files, create main flow,  generate backend REST API flows, map RAML resources to actions.
* APIkit 4.x Tasks: Change APIkit project, customize API console, configure headers, retrieve RAML files, execute nonfunctional requirements, configure load balancers.
* Create Enable O-Data API using APIkit OData Extension: generate Mule flows to handle OData requests.
* Creating an APIkit Project with Maven: add APIkit components to an existing Apache Maven project.

== Consume Data from an API
After you build your application, you can start consuming data from the API. Review the Consume data from an API documentation for guidelines.

== See Also
* APIKit
* APIKit Handling Errors

= DataWeave Selectors
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

DataWeave 2.0 selectors traverse the structures of objects and arrays and
return matching values.
//LINK TO DW 1.0 LANDING PAGE IN MULE 3.9 DOCS:
include::partial$dataweave1-links.adoc[tag=dataweave1LandingPage]

A selector always operates within a context, which can be a reference to
a variable, an object literal, an array literal, or the invocation of a
DataWeave function.

[%header,cols="30,30,40"]
|===
|Selector Type |Syntax |Return Type

| Single-value | `.keyName` | Any type of value that belongs to a matching key
| Multi-value | `.*keyName` | Array of values of any matching keys
| Descendants | `..keyName` | Array of values of any matching descendant keys
| Key-value pair | `.&keyName` | Object with the matching key
| Index | `[<index>]` | Value of any type at selected array index
| Range | `[<index> to <index>]`| Array with values from selected indexes
| XML attribute | `@`, `.@keyName` | String value of the selected attribute
| Namespace | `keyName.#` | String value of the namespace for the selected key
| Key present | `keyName?`, `keyName.@type?` | Boolean (`true` if the
  selected key of an object or XML attribute is present, `false` if not)
| Assert present | `keyName!` | String: Exception message if the key is not present
| Filter |`[?(boolean_expression)]` | Array or object
  containing key-value pairs _if_ the DataWeave expression returns `true`. Otherwise,
  returns the value `null`.
| Metadata | `.^someMetadata` a|
Returns the value of specified metadata for a Mule payload, variable, or
attribute. The selector can return the value of class (`.^class`),
content length (`.^contentLength`), encoding
(`.^encoding`), mime type (`.^mimeType`), media type (`.^mediaType`),
 raw  (`.^raw`), and custom (`.^myCustomMetadata`) metadata. For details, see
xref:dataweave-cookbook-extract-data#selector_metadata[Extract Data].

|===

[NOTE]
====
The examples below use these selectors. For additional examples, see
xref:dataweave-cookbook-extract-data#[Extract Data].
====

////

== Rules for Matching

Selectors that use a name to select data are composed of a namespace and
a local part. When relying on the namespace, the selector only matches a key with
that namespace and that local part. However, if the name only has a local part, the
selector matches all keys with the same local part regardless of whether
the name has namespace or not.

////
SHOKI CHECKED:
DYNAMIC SELECTION ON THE NAMESPACE ISN'T WORKING
WE'LL REMOVE THIS SECTION UNTIL THAT IS FIXED,
MAYBE MULE 4.2.3.
NOTE THAT IT DOES WORK ON THE LOCAL PART. 

== Dynamic Selector

You perform dynamic selection with a `nameExpression` within
square brackets (`[``]`) that returns a `String` type.

* Single Value: `payload[(nameExpression)]`
* Multi Value: `payload[*(nameExpression)]`
* Attribute: `payload[@(nameExpression)]`
* Key Value: `payload[&(nameExpression)]`

//TODO: NEED EXAMPLES. TEXTED Shoki about it on 01/07/2020. MDA on PTO.
////

== Single-Value Selector

This selector matches the value of the first key-value pair where the key
matches the given selector name. The selector can be applied to an Object or
to an Array. On an Array, the selector applies to all Object values inside the
array and ignores all values that are not Object values. If no key matches,
the value `null` returns.

=== Example

This example shows how the selector works on a simple JSON object.

==== Input

The input payload is an object with the key "name" and the
value "DataWeave".

[source,JSON,linenums]
----
{ "name": "Data Weave" }
----

==== Source

The DataWeave script uses `payload.name` to select the
value of the object that has the key `"name"`.
Note that `payload.name` and `payload."name"` are both valid
ways to perform the selection.

[source,DataWeave,linenums]
----
%dw 2.0
output application/json
---
payload.name
----

==== Output

The script outputs the String value of the input object, "Data Weave".

[source,JSON,linenums]
----
"Data Weave"
----

=== Example

On an Array, the selector applies to every element.


==== Input

The input payload is an array that contains two objects with the same
key, "name".

[source,JSON,linenums]
----
[
  {
    "name": "Arg"
  },
  {
    "name": "Japan"
  }
]
----

==== Source

The DataWeave script uses `payload.name` to select the
value of any objects in input payload that have the key, "name".

[source,DataWeave,linenums]
----
%dw 2.0
output application/json
---
payload.name
----

==== Output

The script outputs an array that contains the values of the input objects
with the key "name": "Arg" and "Japan".

[source,json, linenums]
----
["Arg", "Japan"]
----

=== Example

This example selects values from XML elements with different namespaces.

==== Input

The input payload contains XML with two `table` elements under the
`root` element. One `table` element contains the namespace
`"http://www.w3.org/TR/html4/"`. The other contains the namespace
`"https://www.w3schools.com/furniture"`.

[source,xml, linenums]
----
<root>

  <h:table xmlns:h="http://www.w3.org/TR/html4/">
    <h:tr>
      <h:td>Apples</h:td>
      <h:td>Bananas</h:td>
    </h:tr>
  </h:table>

  <f:table xmlns:f="https://www.w3schools.com/furniture">
    <f:name>African Coffee Table</f:name>
    <f:width>80</f:width>
    <f:length>120</f:length>
  </f:table>

</root>
----

[[namespace_variable]]
==== Source

The header of the following DataWeave script creates variables (`html` and
`furniture`) to store values that match the namespaces in the `table` elements
of the input payload. The body of the script uses those variables to select values
from the `table` element with the specified namespace. Using these namespace
selectors makes it possible to return values from both `table` elements. Note
that without the namespace selectors (for example, `payload.root.table` instead
of `payload.root.furniture#table`), the script would only return values from the
first `table` element, not the second.

[source,DataWeave, linenums]
----
%dw 2.0
output application/xml
ns html http://www.w3.org/TR/html4/
ns furniture https://www.w3schools.com/furniture
---
root: {
     a: payload.root.html#table,
     b: payload.root.furniture#table
 }
----

==== Output

The script outputs values from `table` elements with both namespaces.

[source,xml, linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<root>
  <a>
    <h:tr xmlns:h="http://www.w3.org/TR/html4/">
      <h:td>Apples</h:td>
      <h:td>Bananas</h:td>
    </h:tr>
  </a>
  <b>
    <f:name xmlns:f="https://www.w3schools.com/furniture">African Coffee Table</f:name>
    <f:width xmlns:f="https://www.w3schools.com/furniture">80</f:width>
    <f:length xmlns:f="https://www.w3schools.com/furniture">120</f:length>
  </b>
</root>
----

=== Example

This example selects XML values using a local name (`payload.root.table`
instead of `payload.root.furniture#table` in the
<<namespace_variable, previous example>>).

==== Input

The input payload contains XML with a `table` element that contains
the namespace `"http://www.w3.org/TR/html4/"`.

[source,xml, linenums]
----
<root>
  <h:table xmlns:h="http://www.w3.org/TR/html4/">
    <h:tr>
      <h:td>Apples</h:td>
      <h:td>Bananas</h:td>
    </h:tr>
  </h:table>
</root>
----

==== Source

The DataWeave script selects values of children in the `table` element
by using a local name of the XML element `table` instead of its namespace.

[source,DataWeave, linenums]
----
%dw 2.0
output application/xml
---
root: { a: payload.root.table }
----

==== Output

The script outputs XML that contains the values of children in the
`table` element.

[source,xml, linenums]
----
<?xml version='1.0' encoding='UTF-8'?>
<root>
  <a>
    <h:tr xmlns:h="http://www.w3.org/TR/html4/">
      <h:td>Apples</h:td>
      <h:td>Bananas</h:td>
    </h:tr>
  </a>
</root>
----

== Attribute Selector

The attribute selector returns the first attribute value that matches the
selected name expression. If no key matches, the selection returns the value
`null`.

The following example selects the value of an XML attribute.

=== Input

The input payload is an XML `user` element that contains the attribute
`name="Weave"`.

[source,xml, linenums]
----
<user name="Weave"/>
----

=== Source

The DataWeave script selects the value of the `name` attribute
from the input payload (`<user name="Weave"/>`). Notice that the `@`
indicates an attribute selection.

[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
payload.user.@name
----

=== Output

The DataWeave script outputs the value of `name` attribute.

[source,json,linenums]
----
"Weave"
----

== Multi-Value Selector

Instead of returning the value of the first matching key in an array 
of objects, the multi-value selector (`*`) returns an array containing 
values to the matching key (for example, `*user` where `user` is 
the key). The selector does not return the values of descendants, 
only those at the specified level. If no key matches, the selection 
returns the value `null`.

=== Input

The input payload contains an XML array of `user` elements.

[source,xml, linenums]
----
<users>
  <user>Weave</user>
  <user>BAT</user>
  <user>TF</user>
</users>
----

=== Source

The DataWeave script uses the `*user` to select the values of
all `user` elements from the input payload.

[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
payload.users.*user
----

=== Output

The script outputs an array of `user` values.

[source,json,linenums]
----
[
  "Weave",
  "BAT",
  "TF"
]
----

== Descendant Selector

The descendant selector returns a list of all children. You can directly chain
this selector to any other selector without using a single `.`. For example,
`payload..` recursively returns an array of all the child values and the values
of their children, and so on. You can also chain the selector to another element
(for example, with `payload..user`) to select the values of each `user` key and
its descendants, or you can use `payload..*name` to select the values
of all `name` descendants.

=== Example

This example selects each descendant of the input payload.

==== Input

The input payload contains a set of elements that are nested
at different levels.

[source,xml, linenums]
----
<users>
  <user>
    <name>Weave</name>
    <user>
      <name>BAT</name>
      <user>
        <name>BDD</name>
      </user>
    </user>
  </user>
</users>
----

==== Source

The DataWeave script uses `..` to recursively select all elements in
the input payload and return them in a JSON array.

[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
payload..
----

==== Output

[source,json,linenums]
----
[
  {
    "user": {
      "name": "Weave",
      "user": {
        "name": "BAT",
        "user": {
          "name": "BDD"
        }
      }
    }
  },
  {
    "name": "Weave",
    "user": {
      "name": "BAT",
      "user": {
        "name": "BDD"
      }
    }
  },
  "Weave",
  {
    "name": "BAT",
    "user": {
      "name": "BDD"
    }
  },
  "BAT",
  {
    "name": "BDD"
  },
  "BDD"
]
----


=== Example

This example selects the descending `name` values.

==== Input

The input payload contains a set of `name` elements that are nested
at different levels.

[source,xml, linenums]
----
<users>
  <user>
    <name>Weave</name>
    <user>
      <name>BAT</name>
      <user>
        <name>BDD</name>
      </user>
    </user>
  </user>
</users>
----

==== Source

The DataWeave script uses `..` to select the values of all `name` elements
from the input payload and output those values into a JSON array.

[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
payload..name
----

==== Output

The script outputs a JSON array with all `name` values.

[source,json,linenums]
----
[
  "Weave",
  "BAT",
  "BDD"
]
----

[[selectors_variables]]
== Use of Selectors on Content Stored in Variables

All selectors work with the
xref:dataweave-variables-context.adoc[predefined Mule Runtime variables],
such as `payload` and `attributes`, and with
xref:dataweave-variables.adoc[DataWeave variables]. For example, assuming a
DataWeave variable defined as
`var myVar = { "id" : "1234", "name" : "somebody" }`, the DataWeave expression
`myVar.name` returns the value of `"name"`, which is `"somebody"`.

You can select xref:about-mule-event.adoc[Mule event] data by using
Mule Runtime variables.

Extracted values are handled as a literal values (as opposed to
variables, for example) of one of the supported DataWeave value types.

[cols="1,4", options="header"]
|===
| Data to extract | Syntax

| *Payload*
a| `payload`, for example: `payload.name`

If the `payload` is `{"name" : "somebody"}`, `payload.name` returns `"somebody"`.

For more on the Mule payload, see
xref:about-mule-message#_message_payload[Message Payload].

| *Attribute*
a| `attributes.<myAttributeName>`

For examples, see xref:about-mule-message#_attributes[Attributes].

| *Variable*
a|

`<myVariableName>`

To avoid name collisions, you can prepend `variables`:

`variables.<myVariableName>`

For more on Mule variables, see xref:about-mule-variables.adoc[Variables in Mule Apps].

| *Error object*

a| `error`

For information on errors in the flow, you can use `#[error.cause]`.

| *Flow*
a| `flow`

For the flow name in the Logger: `#[flow.name]`

Note that `flow.name` does not work in some Core components, such as Set Payload and Transform Message.

For more on flows, see xref:about-flows.adoc[Flows and Subflows].
|===

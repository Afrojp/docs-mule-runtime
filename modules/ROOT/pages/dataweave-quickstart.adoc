= DataWeave Quickstart
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: studio, anypoint, transform, transformer, format, xml, json, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

In this quickstart, you run DataWeave scripts on sample data, without relying
on external data sources. The examples introduce some key DataWeave concepts and show how to turn the Transform Message component into a DataWeave playground.

You copy DataWeave scripts into the source code area of a Transform Message
component in xref:7.3@studio::index.adoc[Studio], then view the results in the component's *Preview* pane. Once you feel comfortable with DataWeave examples
here and elsewhere in the documentation, you can try out your own DataWeave
scripts on sample data.

[[example1]]
.Transform Message Component in a Studio Project
image::dw-tut-script-studio-basic.png[Simple Script]

The figure shows a Transform Message component in the center canvas (within *testingscriptFlow*). Below the Studio canvas, the *Transform Message* tab
includes a DataWeave script in the source code area with output in the
*Preview* pane.

== Prerequisites

xref:7.3@studio::to-download-and-install-studio.adoc[Studio 7] is required. Version 7.3 or 7.2.3 are recommended. Prior Studio 7 versions are untested
with this quickstart.

Once you are done, you need to set up a project with a Transform Message component. See <<setup>>.

[[setup]]
== Set Up a Studio Project

. In Studio, click *File* -> *New* -> *Mule Project* to create a Mule project.
. Provide a name for the project, and click *Finish*.
. From the *Mule Palette* tab of your new project, click *Core*, and then drag
the *Transform Message* component into the Studio canvas, as shown in <<example1>>.
. [Optional] In the *Transform Message* tab, click the _empty_ rectangle next to *Preview* to expand the source code area, and then click *Preview* to open the Preview pane.
. Proceed to <<start_scripting>>.

[[start_scripting]]
== Start Scripting

. Begin with a simple DataWeave script that outputs the value of the DataWeave
variable `myJson`:
.. Add this script to the source code area of the *Transform Message* tab, as shown in <<example1>>:
+
[source,dw,linenums]
----
%dw 2.0
var myJson = { "hello" : "world" }
output application/json
---
myJson
----
+
Like a JSON object, the `{ "hello" : "world" }` DataWeave object, defined as the
`myJson` variable in the script's header, is a data structure made up of one or
more key-value pairs within curly braces. Learn about
xref:dataweave-language-introduction.adoc[DataWeave Scripts]
and xref:dataweave-variables.adoc[DataWeave Variables].
+
.. Preview the output:
+
[source,json,linenums]
----
{
  "hello": "world"
}
----
+
. Now try an example that uses the DataWeave `avg` function in a DataWeave
variable (`myJson`) to get averages of two sets of numbers.
+
.. Replace the current script in the source code area with this one:
+
[source,dw,linenums]
----
%dw 2.0
var myJson = {
  a: avg([1, 1000]),
  b: avg([1, 2, 3])
}
output application/json
---
myJson
----
+
The `avg` functions here get invoked when you add `myJson` to the body of the
script, producing the calculated averages within the JSON object, which
you can see in the *Preview* pane. The structures `[1, 1000]` and `[1, 2, 3]`
are DataWeave arrays. Learn more about the xref:dw-core-functions-avg.adoc[avg]
function.
+
.. Preview the output:
+
[source,json,linenums]
----
{
  "a": 500.5,
  "b": 2.0
}
----
+
.This Example in Studio
image::dw-tut-script-studio-var.png[Script Using var]
+
. Now try a more complicated script that reads XML input, transforms it to
JSON, and only selects the contents of the `prices` element.
+
.. Replace the current script in the source code area with this one:
+
[source,dw,linenums]
----
%dw 2.0
var myRead = read("<prices><basic>9.99</basic></prices>",
                "application/xml",
                { indexedReader: "false" })
output application/json
---
{
   "JSON" : myRead.prices
}
----
+
If you encounter an issue previewing this example, try changing `myRead.prices`
to `myRead."prices"`. Learn more about the xref:dw-core-functions-read.adoc[read]
function, xref:dataweave-formats.adoc[Formats Supported by DataWeave], and
xref:dataweave-selectors.adoc[DataWeave Selectors].
+
.. Preview the output:
+
[source,json,linenums]
----
{
  "JSON": {
    "basic": "9.99"
  }
}
----
+
. [[readurl]] Now use `readUrl` to read the contents of a file in the Studio
`src/main/resources` folder.
+
.. Add a file by right-clicking the `src/main/resources` folder, then
navigating to *New* -> *File*, providing the file name `myJson.json` for
that file, and clicking *Finish*.
.. From `src/main/resources`, double-click your new `myJson.json` file, and
then provide and save the following sample content in the *myJson.json* tab
(in Studio 7.3, within the *Source* sub-tab of the *myJson.json* tab):
+
[source,json,linenums]
----
{
  "hello": "world"
}
----
+
.myJson.json in Studio
image::dw-tut-sample-file.png[DataWeave Sample File]
+
.. Returning to the Transform Message component, replace the current script with one that uses
`readUrl` to get the JSON contents of your file:
+
[source,dw,linenums]
----
%dw 2.0
output application/json
---
readUrl("classpath://myJson.json", "application/json")
----
+
Learn more about the xref:dw-core-functions-readurl.adoc[readUrl] function.
+
.. View the matching output in the *Preview* pane.
+
[source,json,linenums]
----
{
  "hello": "world"
}
----
+
////
. Now zip and unzip some arrays that are defined in separate DataWeave variables.
.. Replace the current script in the source code area with this one:
+
[source,dw,linenums]
----
%dw 2.0
var array1 = [0, 1, 2]
var array2 = ["a", "b"]
var array3 = [[0,"a"],[1,"b"]]
output application/json
---
{
  "zip1" : zip(array1, array2),
  "zip2" : zip(array2, array1),
  "unzip1" : unzip(array3)
}
----
+
.. Preview the output:
+
[source,json,linenums]
----
{
  "zip1": [
    [ 0, "a" ],
    [ 1, "b" ]
  ],
  "zip2": [
    [ "a", 0 ],
    [ "b", 1 ]
  ],
  "unzip1": [
    [ 0, 1 ],
    [ "a", "b" ]
  ]
}
----
+
Notice how the functions regroup the elements from the input arrays. Learn more about the xref:dw-core-functions-zip.adoc[zip] and
xref:dw-core-functions-unzip.adoc[unzip] functions.
////
+
. Now map elements within an array to keys and values of an object.
.. [[input_map]] Replace the current script in the source code area with this one:
+
[source,dw,linenums]
----
%dw 2.0
output application/json
---
{
  (
    ["a", "b", "c"] map ((value, index) -> {
        (index): value
    })
  )
}
----
+
The `map` function iterates over the array on the left to apply the lambda
(anonymous function) on the right to elements in that array. The lambda uses
xref:dataweave-functions-lambdas.adoc#_use_named_parameters_in_a_lambda[named parameters] (`value` and `index`) to select the values and indices from the
array and populate a DataWeave object with key-value pairs. Learn about
xref:dw-core-functions-map.adoc[map], and compare `map` with xref:dw-core-functions-mapobject.adoc[mapObject], which takes an object as
input.
+
.. [[output_map]] Preview the output:
+
[source,json,linenums]
----
{
  "0": "a",
  "1": "b",
  "2": "c"
}
----
+
.. Now run `pluck` on the <<output_map, output>> of the `map` example:
+
[source,dw,linenums]
----
%dw 2.0
output application/json
---
{
  "0": "a",
  "1": "b",
  "2": "c"
} pluck ((value) -> value)
----
+
This example iterates over the values in the input object and outputs them into
an array that matches the <<input_map, input>> from the `map` example. Learn more about xref:dw-core-functions-pluck.adoc[pluck].
+
.. Preview the output:
+
[source,json,linenums]
----
[
  "a",
  "b",
  "c"
]
----
+
. Now try a complex example that maps and merges fields from items in separate arrays.
.. Replace the current script in the source code area with this one:
+
[source,dw,linenums]
----
%dw 2.0
var myVar = [
  { bookId: 101,
    title: "world history",
    price: "19.99"
  },
  {
    bookId: 202,
    title: 'the great outdoors',
    price: "15.99"
  }
]
var myVar2 = [
  {
    bookId: 101,
    author: "john doe"
  },
  {
    bookId: 202,
    author: "jane doe"
  }
]
output application/json
---
myVar map (item, index) -> using (id = item.bookId) {
	"id" : id,
	"topic" : item.title,
	"cost" : item.price as Number,
	(myVar2 filter ($.*bookId contains id) map (item) -> {
		author : item.author
	})
}
----
+
Learn more about the xref:dw-core-functions-filter.adoc[filter] function
(used to get the `author` values from the array in the `myVar2` variable),
xref:dataweave-types-coercion.adoc[Type Coercion with DataWeave] (for
`as Number`), and
xref:dataweave-variables#example_local_variable[Examples: Local DataWeave Variables] (for `using (id = item.bookId)`).
+
.. Preview the output:
+
[source,json,linenums]
----
[
  {
    "id": "101",
    "topic": "world history",
    "cost": 19.99,
    "author": "john doe"
  },
  {
    "id": "202",
    "topic": "the great outdoors",
    "cost": 15.99,
    "author": "jane doe"
  }
]
----
+
. Now try to modify an example so that you can run it with sample data in the Transform Message component:
.. Start with this script in the Output area:
+
[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
ContainsRequestedItem: payload.root.*order.*items contains "3"
----
+
Notice that you cannot preview it yet:
+
image::dw-tut-payload-example.png[Script Without Input Payload]
+
Learn more about the xref:dw-core-functions-contains.adoc[contains] function and about
the built-in `payload` variable, in xref:dataweave-variables-context.adoc[Mule Runtime variables].
+
.. [[modify_payload]] Now modify this example so that it uses some sample input instead of
attempting to use an input `payload` from a Mule message that does not exist:
+
* Add a `myInput` DataWeave variable that supplies input data the script can read, and
change the Mule `payload` variable in the body of the script to the  DataWeave `myInput`
variable.
+
[source,DataWeave, linenums]
----
%dw 2.0
var myInput = read("<root>
    <order>
      <items>1</items>
      <items>3</items>
    </order>
    <order>
      <items>2</items>
    </order>
</root>",
"application/xml")
output application/json
---
ContainsRequestedItem: myInput.root.*order.*items contains "3"
----
* Preview the results:
+
[source,json,linenums]
----
{
  "ContainsRequestedItem": true
}
----

Find many more examples to try out in Studio here:

* xref:dw-functions.adoc[DataWeave Reference] (provides many examples
that use functions provided by DataWeave function modules)
* xref:dw-operators.adoc[DataWeave Operators]
* xref:dataweave-flow-control.adoc[Flow Control in DataWeave]
* xref:dataweave-pattern-matching.adoc[Pattern Matching in DataWeave]
* xref:dataweave-cookbook.adoc[DataWeave Cookbook]
* xref:dataweave-functions.adoc[Define DataWeave Functions]

NOTE: To modify DataWeave examples that use the built-in Mule variable, `payload`, you can provide sample input data through a DataWeave variable (`var`) in the header of your DataWeave script (as shown
<<modify_payload, the last step>>) or from a file that you read into a DataWeave variable, as shown in the <<readurl, readUrl>> example, then
replace `payload` with the DataWeave variable name.

== Next Steps

To create an example that uses `payload`, you need to create and run a Mule app
to generate the payload within a xref:about-mule-event.adoc[Mule event].

To get started with Mule app development and data mapping, see the
xref:mule-app-tutorial.adoc[Mule App Tutorial].

Beyond Transform Message, many Mule connectors, modules, and Core components accept short DataWeave expressions in their *fx* fields. To learn about them, you can start with xref:mule-application-about.adoc[Mule Applications].

When you are learning to create your own Mule apps, some useful Core components for trying out sample data without depending on external data sources are
xref:set-payload-transformer-reference.adoc[Set Payload] to provide content for the payload of a Mule event, xref:variable-transformer-reference.adoc[Set Variable] to create content in a Mule event variable, and the
xref:scheduler-concept.adoc[Scheduler] to trigger the regular generation
of Mule events to hold any data set by those components.

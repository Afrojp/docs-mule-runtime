= XA Transactions
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: xa, transactions, jms, vms, db, ibmmq

The Extended Architecture Transactions (or **XA Transactions**) can be used to group together a series of operations from multiple transactional resources, such as VM, JMS or DB resources, into a single reliable global transaction.  

The https://en.wikipedia.org/wiki/X/Open_XA[*XA* (eXtended Architecture)] standard is an *X/Open group* standard which specifies the interface between a *global transaction manager* and *local transactional resource managers*. The XA protocol defines a 2-phase commit protocol which can be used to more reliably coordiate and sequence a series of "all or nothing" (atomic) operations across multiple servers, even servers of different types. Each local XA resource manager supports the https://en.wikipedia.org/wiki/ACID[*A.C.I.D* properties] which help guarantee "all or nothing" completion of a sequence of operations in the resource managed by the XA resource manager. Examples of transactional systems which often include local XA resource managers include databases, application servers, messaging queues, and transactional caches.

The global transaction manager is then responsible for coordinating the transactional semantics of the global transaction between all the local XA transaction managers participating in the global transaction. To do this, each prepare and commit phase in the 2-phase commit is coordinated globally (often over the network) with each local XA resource manager.

The advantage of XA global transactions is that one global transaction manager can communicate and coordinate with multiple different transactional resources in a commmon and standard way. If any of the local resource managers report an error in the global transaction, the global transaction manager coordinates the rollback of any already prepared operations in each of the other local resource managers.
For example, a global transaction might include several operations to one or more databases, as well as messages sent to a JMS server on one or more topics. If anything goes wrong in the transaction, the global transaction manager guarantees that every resource is reset to the state before the global transaction was started. This keeps developers from having to include complex rollback or recovery logic outside the application.

The disadvantage of XA global transactions is that they can add tremendous latency to your transactions, especially if resources are distributed over slow or unreliable network connections, and it can be difficult to recover if there are physical failures of systems in the middle of a global distributed transaction.


== XA Transactions and Performance

A global XA transaction is often a more reliable way of coordinating multiple XA resources, but often increases latency, and also often requires additional resources such as an external transaction manager. Also, a global transaction is only as reliable as the global transaction manager itself. For greater reliability, you will need to use a transaction manager with also persists the state of each XA resource as the global transaction progresses through the prepare and commit phases, in case the transaction manager itself fails, or looses network connectivity to any of the local XA resource managers, during the global transaction.

== Configuring your Resource to use XA Transactions

To configure the message sources that supports XA transaction, please check out the connectors documentation:

* JMS
* IBMMQ
* VM
* DB

== Configuring Try Scope to use XA Transactions

To configure a Try Scope to run a XA Transaction:

1. Add the Try Scope from the Mule Palette. 
2. Go to the Try configuration panel, to the General tab. 
3. Configure the Try Scope `Transactional Action` to `ALWAYS_BEGIN`, and the `Transaction Type` to `XA`. 

See also xref:try-scope-concept.adoc[Try Scope Concept] for more information on how Try Scope handles transactions.

== Using XA Transactions with Different Resources

Regardless of how the Transaction is began (i.e. Transactional Message Source or Try Scope), then any other Connector Operation that supports Transactions may join the Transaction, by setting its Transactional Action to `ALWAYS_JOIN` or `JOIN_IF_POSSIBLE`. Since XA Transactions are meant to work with different resources, you can have different resources operations join the transaction. For example: 

[source,xml,linenums]
----
<flow name="exampleFlow" >
	<try transactionalAction="ALWAYS_BEGIN" transactionType="XA">
		<set-payload value="Hello World"/>
		<vm:publish queueName="someVmQueue" config-ref="VM_Config"/>
		<jms:consume config-ref="JMS_Config" destination="someQueue"/>
		<db:insert config-ref="Database_Config">
			<db:sql>${insertQuery}</db:sql>
		</db:insert>
	</try>
	<error-handler>
		<on-error-propagate enableNotifications="true" logException="true"/>
	</error-handler>
</flow>
----

Suppose the `db:insert` operation fails, then before the error handler (`on-error-propagate`) is executed, the transaction is rolled back. Therefore, the message sent through the `vm:publish` is not confirmed to be sent, and
the message in the `jms:consume` is not actually consumed, so it is available next time to be consumed again. 

Suppose now the error handler is changed to an `on-error-continue`:

[source,xml,linenums]
----
<flow name="exampleFlow" >
	<try transactionalAction="ALWAYS_BEGIN" transactionType="XA">
		<set-payload value="Hello World"/>
		<vm:publish queueName="someVmQueue" config-ref="VM_Config"/>
		<jms:consume config-ref="JMS_Config" destination="someQueue"/>
		<db:insert config-ref="Database_Config">
			<db:sql>${insertQuery}</db:sql>
		</db:insert>
	</try>
	<error-handler>
		<on-error-continue enableNotifications="true" logException="true">
			<jms:publish config-ref="ANOTHER_JMS_Config" destination="someOtherQueue" transactionalAction="ALWAYS_JOIN"/>
		</on-error-continue>
	</error-handler>
</flow>
----

Now, if the `db:insert` operation fails, the transaction is not rolled back. Instead, the Transaction is commited after the `jms:publish` (which runs within the XA Transaction) executes. Therefore, the message sent using `vm:publish` is pubished, the message from `jms:consume` is consumed, and the message publish with `jms:publish` is also sent. Consider that the `jms:publish` inside the `on-error-continue` has another configuration for the connector. This is not required, but is possible. With single source (local) Transactions, this is not a valid configuration, since all operations running within a Transaction (that joins it) must use the same Configuration to work as designed. 

== See Also

* xref:using-bitronix-to-manage-transactions.adoc[Using Bitronix to Manage Transactions]
* xref:transaction-management.adoc[Transaction Management].

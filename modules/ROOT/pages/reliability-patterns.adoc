= Reliability Patterns
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: reliability, patterns, cluster, ha, transaction, delivery, ensure

== Overview

A high-reliability application (one that has zero tolerance for message loss) not only requires the underlying Runtime to be reliable, but that reliability needs to extend to individual connections. If your application uses a transactional connection such as JMS, VM, or DB, reliable messaging is ensured by the built-in support for transactions in the connector. This means, for example, that you can configure a transaction on a JMS listener that makes sure messages are only removed from the JMS server when the transaction is committed. By doing this, you ensure that if an error occurs while processing the message, it will still be available for reprocessing. 

In other words, the transactional support in these connectors ensures that messages are delivered reliably from a source to an operation or between processors within a flow. Note though that if you want to move messages between different connectors that support transactions you need to use XA transactions to ensure that both transports' transactions are committed as one atomic unit. See xref:transaction-management.adoc[Transaction Management] for more information on XA and other types of transactions.

However, suppose you have a web application that uses a non-transactional connector such as HTTP. How do you ensure reliable messaging for your application? The answer is to follow a reliability pattern.

[NOTE]
Note that VM file persistency is disabled on clusters, so VM endpoints persist in-memory in a clustered topology.

== What is a Reliability Pattern?

A *reliability pattern* is a design that results in reliable messaging for an application even if the application receives messages from a non-transactional transport. A reliability pattern couples a reliable acquisition flow with an application logic flow, as shown in the following diagram.

image::reliability-pattern.png[Reliability_Pattern]

The *reliable acquisition flow* (that is, the left-hand part of the diagram) delivers a message reliably from a Message Source (that does not implement transactions) to an outbound operation of a connector that implements transactions. The operation can be any type of transactional endpoint such as VM or JMS. If the reliable acquisition flow cannot deliver the message, it ensures that the message isn't lost:

* For socket-based connections like HTTP, this means returning an "unsuccessful request" response to the client so that the client can retry the request.
* For resource-based connections like File or FTP, it means not deleting the file, so that it can be reprocessed.

The *application logic flow* (that is, the right-hand side of the diagram) delivers the message from the Message Source (which uses a transactional connector) to the business logic for the application.

== Comparing Endpoints in Reliability Patterns

As mentioned earlier, you can couple the reliable acquisition flow with any type of transactional endpoint – you don't have to use a VM endpoint in a reliability pattern. The following diagram illustrates a reliability pattern where the reliable acquisition flow delivers a message to a JMS endpoint.

image::reliabilitypatternwithjms.png[ReliabilityPatternwithJMS]

However, because the VM connector, by default, uses in-memory queues, it can be much faster than another transactional endpoint such as JMS.

The following table lists the advantages and disadvantages of using VM, JMS, and JDBC endpoints in a reliable acquisition flow.

[%header,cols="10,80,10"]
|===
|Endpoint |Advantage |Disadvantage
|VM (standalone Mule) |Faster than JMS because everything is in memory and in-process. Provided out of the box with Mule – no need to purchase additional software. |Data lost when Mule exits. Non-clustered.
|File-based VM (standalone Mule) |Provided out of the box with Mule – no need to purchase additional software. |Non-clustered.
|VM (Mule HA cluster) |Faster than JMS because everything is in shared memory. Provided out of the box with Mule – no need to purchase additional software. |Data lost when entire Mule cluster exits.
|JDBC |Depending on resources available, can hold a very large amount of information. |Can be complex to use, since proper DBMS schemas are required
|JMS (not enabled for persistence) |Allows sharing data with other Mule instances or non-Mule clients. |Slower than VM because it is in another process.
|JMS (enabled for persistence) |Most reliable choice because messages are persisted to disk. |Slower than VM because of disk access.
|===

== Implementing a Reliability Pattern

Here is a code example that shows what a complete reliability pattern would look like (that is, including the reliable acquisition flow and application logic flow). In this example, the reliable acquisition flow part of the reliability pattern is HTTP-to-VM. Note that VM file persistency, shown below, does not work on clusters.

[source,xml,linenums]
----
	<!-- This is the reliable acquisition flow in the reliability pattern.  -->
	<flow name="reliable-data-acquisition">
		<http:listener config-ref="HTTP_Listener_config" path="transactionalEndpoint"/>
		<vm:publish config-ref="VM_Config" queueName="toTransactionalVM"/> <!--1-->
	</flow>

	<!-- This is the application logic flow in the reliability pattern.
		It is a wrapper around a sub-flow, "business-logic-processing".
	-->
	<flow name="main-flow">
		<vm:listener doc:name="Listener" config-ref="VM_Config" queueName="toTransactionalVM" 
			transactionalAction="ALWAYS_BEGIN"/> <!--2-->
		<flow-ref name="business-logic-processing"/>
	</flow>
	
	<!-- This is where the real work of the application will happen. -->
	<sub-flow name="business-logic-processing">
		<!--
			This flow is where the actual business-logic is performed.
		-->
	</sub-flow>
----
<1> The message is written to the VM queue. It is now available for processing by the main flow.
<2> The message is read from the VM queue transactionally. This ensures that if any error occurs, the read will be rolled back and the message reprocessed.


== Implementing a Reliable Acquisition Flow

Let's focus on the reliable acquisition flow part of the reliability pattern. Furthermore, let's concentrate on reliable acquisition flows that have a non-transactional Message Source. You've already seen in Implementing a Reliable Message Pattern what a reliable acquisition flow for an HTTP listener to a VM or JMS publish-operation looks like. Let's look at three other scenarios: FTP-to-VM (Or SFTP, FTPS), File-to-VM, and IMAP-to-VM. In this case, we are focusing on resource-based connections. In this case, we need to ensure to read the resource only once. This could be done by enabling `watermark`. You should not set the `auto-delete` parameter to `true`, since it will delete the file as soon as the flow finishes, even though the process will be done by another flow (same goes to `moveToDirectory`). 

=== FTP to VM

The following code implements a reliable acquisition flow from an FTP listener (On New or Updated File) to a VM queue by a publish operation:

[source,xml,linenums]
----
	<ftp:config name="FTP_Config">
		<ftp:connection host="localhost" username="max" password="mulesoft"/>
	</ftp:config>
	<flow name="reliable-data-acquisition"> 
		<ftp:listener config-ref="FTP_Config" watermarkEnabled="true" directory="someDirectory/in"> <!--1-->
			<scheduling-strategy >
				<fixed-frequency />
			</scheduling-strategy>
		</ftp:listener>
		<vm:publish config-ref="VM_Config" queueName="toTransactionalVM"/>
	</flow>

	<flow name="doc-examplesFlow">
		<vm:listener queueName="toTransactionalVM" config-ref="VM_Config" transactionalAction="ALWAYS_BEGIN"/>
		<set-variable value="#[attributes.filename]" variableName="filepath"/>
		<!-- File content is already present in payload --> 
		<flow-ref name="business-logic-processing"/>
		<ftp:delete path="#[vars.filepath]"/> <!--2-->
	</flow>
</mule>
----
<1> In case you wish to perform a transformation before publishing to VM, you may add a max redelivery count. 
<2> If file is not intended to be deleted, you may not use the Delete Operation (same if operation inteded is Move)

Similar implementation is done for any other of the resourced-based connectors.

== General Considerations

Here are a number of things to consider in implementing the reliability pattern:

* Always use a transaction when the connector (Message Source) allows you to do so.
* Use an XA transaction for bridging Message Sources, that is, where you want to enlist multiple managed resources within the same transaction.
* The reliability of JMS is tied to the MQ implementation and how it is configured. Most MQ implementations allow you to configure whether messages are to be stored in memory only or to be persisted. You can achieve reliability only if you configure the MQ server to persistently store messages before sending them forward. Otherwise, you risk losing messages in case of an MQ server crash.
* **Reliability has performance implications**.
* If the outbound opreation in the reliable acquisition flow is not transactional (for example, a flow from file-to-FTP), the only way to ensure message delivery is to use a xref:try-scope-concept.adoc[Try Scope].

